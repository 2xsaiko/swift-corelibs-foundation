import Foundation
import CoreFoundation

// NSError and CFError conform to the standard ErrorType protocol. Compiler
// magic allows this to be done as a "toll-free" conversion when an NSError
// or CFError is used as an ErrorType existential.

extension NSError : ErrorType {
  public var _domain: String { return domain }
  public var _code: Int { return code }
}

extension CFError : ErrorType {
  public var _domain: String {
    return CFErrorGetDomain(self) as String
  }

  public var _code: Int {
    return CFErrorGetCode(self)
  }
}

// An error value to use when an Objective-C API indicates error
// but produces a nil error object.
public enum _GenericObjCError : ErrorType {
  case NilError
}

/// An intrinsic used by the runtime to create an error when an
/// Objective-C API indicates failure but produces a nil error.
@asmname("_swift_allocNilObjCError")
func _allocNilObjCError() -> ErrorType {
  return _GenericObjCError.NilError
}

/// An internal protocol to represent Swift error enums that map to standard
/// Cocoa NSError domains.
public protocol _ObjectiveCBridgeableErrorType : ErrorType {
  /// Produce a value of the error type corresponding to the given NSError,
  /// or return nil if it cannot be bridged.
  init?(_bridgedNSError: NSError)
}

%{

# Cocoa domains and their mapping information.
#
# Each entry in this dictionary is a mapping from the name of the
# enumeration type to the set of errors in that domain.
mappedDomains = {
  'NSCocoaError': [
    # TODO: Split this up into subdomains based on the Minimum/Maximum
    # delimited ranges?

    # Foundation errors
    ('NSFileNoSuchFileError', '', 0),
    ('NSFileLockingError', '', 0),
    ('NSFileReadUnknownError', '', 0),
    ('NSFileReadNoPermissionError', '', 0),
    ('NSFileReadInvalidFileNameError', '', 0),
    ('NSFileReadCorruptFileError', '', 0),
    ('NSFileReadNoSuchFileError', '', 0),
    ('NSFileReadInapplicableStringEncodingError', '', 0),
    ('NSFileReadUnsupportedSchemeError', '', 0),
    ('NSFileReadTooLargeError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSFileReadUnknownStringEncodingError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSFileWriteUnknownError', '', 0),
    ('NSFileWriteNoPermissionError', '', 0),
    ('NSFileWriteInvalidFileNameError', '', 0),
    ('NSFileWriteFileExistsError', 'available(OSX 10.7, iOS 5.0, *)', 0),
    ('NSFileWriteInapplicableStringEncodingError', '', 0),
    ('NSFileWriteUnsupportedSchemeError', '', 0),
    ('NSFileWriteOutOfSpaceError', '', 0),
    ('NSFileWriteVolumeReadOnlyError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSKeyValueValidationError', '', 0),
    ('NSFormattingError', '', 0),
    ('NSUserCancelledError', '', 0),
    ('NSFeatureUnsupportedError', 'available(OSX 10.8, iOS 6.0, *)', 0),
    ('NSExecutableNotLoadableError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableArchitectureMismatchError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableRuntimeMismatchError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableLoadError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableLinkError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSPropertyListReadCorruptError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListReadUnknownVersionError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListReadStreamError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListWriteStreamError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListWriteInvalidError', 'available(OSX 10.10, iOS 8.0, *)', 0),

    ('NSXPCConnectionInterrupted', 'available(OSX 10.8, iOS 6.0, *)', 0),
    ('NSXPCConnectionInvalid', 'available(OSX 10.8, iOS 6.0, *)', 0),
    ('NSXPCConnectionReplyInvalid', 'available(OSX 10.8, iOS 6.0, *)', 0),

    ('NSUbiquitousFileUnavailableError', 'available(OSX 10.9, iOS 7.0, *)', 0),
    ('NSUbiquitousFileNotUploadedDueToQuotaError', 'available(OSX 10.9, iOS 7.0, *)', 0),
    ('NSUbiquitousFileUbiquityServerNotAvailable', 'available(OSX 10.9, iOS 7.0, *)', 0),

    ('NSUserActivityHandoffFailedError', 'available(OSX 10.10, iOS 8.0, *)', 0),
    ('NSUserActivityConnectionUnavailableError', 'available(OSX 10.10, iOS 8.0, *)', 0),
    ('NSUserActivityRemoteApplicationTimedOutError', 'available(OSX 10.10, iOS 8.0, *)', 0),
    ('NSUserActivityHandoffUserInfoTooLargeError', 'available(OSX 10.10, iOS 8.0, *)', 0),

    ('NSCoderReadCorruptError', 'available(OSX 10.11, iOS 9.0, *)', 0),
    ('NSCoderValueNotFoundError', 'available(OSX 10.11, iOS 9.0, *)', 0),

    # CoreData errors.
    ('NSManagedObjectValidationError', '', 1550),
    ('NSValidationMultipleErrorsError', '', 1560),
    ('NSValidationMissingMandatoryPropertyError', '', 1570),
    ('NSValidationRelationshipLacksMinimumCountError', '', 1580),
    ('NSValidationRelationshipExceedsMaximumCountError', '', 1590),
    ('NSValidationRelationshipDeniedDeleteError', '', 1600),
    ('NSValidationNumberTooLargeError', '', 1610),
    ('NSValidationNumberTooSmallError', '', 1620),
    ('NSValidationDateTooLateError', '', 1630),
    ('NSValidationDateTooSoonError', '', 1640),
    ('NSValidationInvalidDateError', '', 1650),
    ('NSValidationStringTooLongError', '', 1660),
    ('NSValidationStringTooShortError', '', 1670),
    ('NSValidationStringPatternMatchingError', '', 1680),
    ('NSManagedObjectContextLockingError', '', 132000),
    ('NSPersistentStoreCoordinatorLockingError', '', 132010),
    ('NSManagedObjectReferentialIntegrityError', '', 133000),
    ('NSManagedObjectExternalRelationshipError', '', 133010,),
    ('NSManagedObjectMergeError', '', 133020),
    ('NSManagedObjectConstraintMergeError', '', 133021),
    ('NSPersistentStoreInvalidTypeError', '', 134000),
    ('NSPersistentStoreTypeMismatchError', '', 134010),
    ('NSPersistentStoreIncompatibleSchemaError', '', 134020),
    ('NSPersistentStoreSaveError', '', 134030),
    ('NSPersistentStoreIncompleteSaveError', '', 134040),
    ('NSPersistentStoreSaveConflictsError', '', 134050),
    ('NSCoreDataError', '', 134060),
    ('NSPersistentStoreOperationError', '', 134070),
    ('NSPersistentStoreOpenError', '', 134080),
    ('NSPersistentStoreTimeoutError', '', 134090),
    ('NSPersistentStoreUnsupportedRequestTypeError', '', 134091),
    ('NSPersistentStoreIncompatibleVersionHashError', '', 134100),
    ('NSMigrationError', '', 134110),
    ('NSMigrationCancelledError', '', 134120),
    ('NSMigrationMissingSourceModelError', '', 134130),
    ('NSMigrationMissingMappingModelError', '', 134140),
    ('NSMigrationManagerSourceStoreError', '', 134150),
    ('NSMigrationManagerDestinationStoreError', '', 134160),
    ('NSEntityMigrationPolicyError', '', 134170),
    ('NSSQLiteError', '', 134180),
    ('NSInferredMappingModelError', '', 134190),
    ('NSExternalRecordImportError', '', 134200),
  ],
}

mappedDomainsOSX = {
  'NSCocoaError': [
    # Foundation errors
    ('NSFileManagerUnmountUnknownError', 'available(OSX 10.11, *)', 0),
    ('NSFileManagerUnmountBusyError', 'available(OSX 10.11, *)', 0),
    # AppKit errors
    ('NSTextReadInapplicableDocumentTypeError', '', 65806),
    ('NSTextWriteInapplicableDocumentTypeError', '', 66062),
    ('NSServiceApplicationNotFoundError', '', 66560),
    ('NSServiceApplicationLaunchFailedError', '', 66561),
    ('NSServiceRequestTimedOutError', '', 66562),
    ('NSServiceInvalidPasteboardDataError', '', 66563),
    ('NSServiceMalformedServiceDictionaryError', '', 66564),
    ('NSServiceMiscellaneousError', '', 66800),    
    ('NSSharingServiceNotConfiguredError', '', 67072),
  ]
}
}%

%for domain in mappedDomains:

// TODO: API review for how to name these enums and cases.
%{
EnumName = "_" + domain
}%

// Non-zero constant values in the table indicate constants that come
// from another framework (AppKit or CoreData) and need to be copied here.
%  for (name, availability, id) in mappedDomains[domain]:
%    if id != 0:
private let ${name}: Int = ${id}
%    end
%  end
%  if mappedDomainsOSX.has_key(domain):
#if os(OSX)
%    for (name, availability, id) in mappedDomainsOSX[domain]:
%      if id != 0:
private let ${name}: Int = ${id}
%      end
%    end
#endif
%  end

public enum ${EnumName} : Int, _ObjectiveCBridgeableErrorType {
%  for (name, availability, id) in mappedDomains[domain]:
  case ${name[2:]}
%  end
%  if mappedDomainsOSX.has_key(domain):
#if os(OSX)
%    for (name, availability, id) in mappedDomainsOSX[domain]:
  case ${name[2:]}
%    end
#endif
%  end

  public var _domain: String { return ${domain}Domain }
  public var _code: Int {
    switch self {
%  for (name, availability, id) in mappedDomains[domain]:
    case ${EnumName}.${name[2:]}:
%    if availability != '':
      guard #${availability} else {
        fatalError("${name} not available on this OS version")
      }
%    end
      return ${name}
%  end
    default:
%    if mappedDomainsOSX.has_key(domain):
#if os(OSX)
%      for (name, availability, id) in mappedDomainsOSX[domain]:
%        if availability != '':
      if #${availability} {
%        end
        if self == ${EnumName}.${name[2:]} {
          return ${name}
        }
%        if availability != '':
      }
%        end
%      end
#endif
%    end
      fatalError("unhandled error code in ${EnumName}")
    }
  }

  public init?(_bridgedNSError: NSError) {
    if _bridgedNSError.domain != ${domain}Domain {
      return nil
    }

    let code = _bridgedNSError.code
%  for (name, availability, id) in mappedDomains[domain]:
%   if availability != '':
    if #${availability} {
%   end
      if code == ${name} {
        self = ${EnumName}.${name[2:]}
        return
      }
%   if availability != '':
    }
%   end
%  end
%  if mappedDomainsOSX.has_key(domain):
#if os(OSX)
%    for (name, availability, id) in mappedDomainsOSX[domain]:
%      if availability != '':
    if #${availability} {
%      end
      if code == ${name} {
        self = ${EnumName}.${name[2:]}
        return
      }
%      if availability != '':
    }
%      end
%    end
#endif
%  end
    return nil
  }
}

%end

/// A hook for the runtime to use _ObjectiveCBridgeableErrorType in order to
/// attempt an "errorTypeValue as? SomeError" cast.
///
/// If the bridge succeeds, the bridged value is written to the uninitialized
/// memory pointed to by 'out', and true is returned. Otherwise, 'out' is
/// left uninitialized, and false is returned.
@asmname("swift_stdlib_bridgeNSErrorToErrorType")
public func _stdlib_bridgeNSErrorToErrorType<
  T : _ObjectiveCBridgeableErrorType
>(error: NSError, out: UnsafeMutablePointer<T>) -> Bool {
  if let bridged = T(_bridgedNSError: error) {
    out.initialize(bridged)
    return true
  } else {
    return false
  }
}
